#!/usr/bin/env python3
import argparse
import os
import sys
from time import asctime

from memmap_table.mathexpression import MathTerm
from mock_processing import PipeLogger, expand_path, open_datastore
from mock_processing.readwrite import (BUFFERSIZE, guess_format,
                                       supported_writers)
from mock_processing.utils import ModificationStamp, build_history


parser = argparse.ArgumentParser(
    description="Select a (sub-)sample of the pipeline output and save it "
                "in a different data format")

parser.add_argument(
    "datastore", type=expand_path,
    help="directory in which the data store is created")
parser.add_argument(
    "-q", "--query",
    help="expression to select a subset of the pipeline output "
         "(default: select all entries)")

output_group = parser.add_argument_group("output table")
output_group.add_argument(
    "-o", "--output", type=expand_path,
    help="path to output data table (default: write on stdout)")
output_group.add_argument(
    "--format", choices=sorted(supported_writers.keys()),
    help="output table file format (default: inferred from file extension)")
output_group.add_argument(
    "-c", "--columns", nargs="*",
    help="only write these columns to the output table (order preserved)")


def main():

    args = parser.parse_args()
    logger = PipeLogger(__file__)
    # determine if output goes to stdout in CSV format (allows redirecting)
    to_stdout = args.output is None
    if to_stdout:  # only print in case of error
        logger.setTermLevel("error")

    # read the input table and write the selected entries to the output file
    with open_datastore(args.datastore, logger) as table:

        # parse the math expression
        if args.query is not None:
            # Since the symbol / can be used as column name and division
            # symbol, we need to temporarily substitute the symbol before
            # parsing the expression.
            substitute = "#"
            try:
                # apply the substitutions to all valid column names apperaing
                # in the math expression to avoid substitute intended divisions
                for colname in table.colnames:
                    substitue = colname.replace("/", substitute)
                    while colname in args.query:
                        args.query = args.query.replace(colname, substitue)
                expression = MathTerm.from_string(args.query)
                # recursively undo the substitution
                expression._substitute_characters(substitute, "/")
                # display the interpreted expression
                message = "apply selection: {:}".format(expression.expression)
                logger.info(message)
            except SyntaxError as e:
                message = e.args[0].replace(substitute, "/")
                logger.handleException(SyntaxError(message))
            except Exception as e:
                logger.handleException(e)
        else:
            expression = None

        # check the requested columns
        if args.columns is not None:
            # check for duplicates
            requested_columns = set()
            for colname in args.columns:
                if colname in requested_columns:
                    message = "duplicate column: {:}".format(colname)
                    logger.handleException(KeyError(message))
                requested_columns.add(colname)
            # find requested columns that do not exist in the table
            missing_cols = requested_columns - set(table.colnames)
            if len(missing_cols) > 0:
                message = "column {:} not found: {:}".format(
                    "name" if len(missing_cols) == 1 else "names",
                    ", ".join(sorted(missing_cols)))
                logger.handleException(KeyError(message))

            n_cols = len(requested_columns)
            message = "select a subset of {:d} column".format(n_cols)
            if n_cols > 1:
                message += "s"
            logger.info(message)

        # automatically determine the format file format
        if args.output is None:  # write to stdout in csv format
            args.format = "csv"
        if args.format is None:
            try:
                args.format = guess_format(args.output)
            except NotImplementedError as e:
                logger.handleException(e)
        message = "writing output as {:}: {:}".format(
            args.format.upper(), args.output)
        logger.info(message)

        # create a standardized output writer
        writer_class = supported_writers[args.format]
        try:
            writer = writer_class(args.output, overwrite=True)
        except Exception as e:
            logger.handleException(e)

        with writer:

            # determine an automatic buffer/chunk size
            chunksize = BUFFERSIZE // table.itemsize
            buffersize = chunksize * table.itemsize
            message = "buffer size: {:.2f} MB ({:,d} rows)".format(
                buffersize / 1024**2, chunksize)
            logger.debug(message)

            # query the table and write to the output fie
            logger.info("processing input stream ...")
            row_message = "entries selected: {:,d} / {:,d}\r"
            if not to_stdout:
                sys.stdout.write(row_message.format(0, 0))
                sys.stdout.flush()
            n_select = 0
            for start, end in table.row_iter(chunksize):

                # read the chunk and optionally select a subset of columns
                chunk = table[start:end]
                if args.columns is None:
                    selection = chunk
                else:
                    selection = chunk[args.columns]

                # apply the optional selection
                if expression is not None:
                    try:
                        mask = expression(chunk)  # all columns for selection
                        selection = selection[mask]
                    except Exception as e:
                        logger.handleException(e)

                # write to target
                writer.write_chunk(selection.to_records())
                n_select += len(selection)
                if not to_stdout:
                    sys.stdout.write(row_message.format(n_select, end))
                    sys.stdout.flush()

            # write a summary of the data store history if possible
            if hasattr(writer, "write_history"):
                date_width = 24
                for date, call in build_history(table, logger).items():
                    writer.write_history(
                        "{:} : {:}".format(date.ljust(date_width), call))
                # add the call of this script
                call = ModificationStamp(sys.argv)._attrs["created by"]
                writer.write_history(
                    "{:} : {:}".format(asctime().ljust(date_width), call))

        message = "wrote {:,d} matching entries (total: {:,d})"
        logger.info(message.format(n_select, end))


if __name__ == "__main__":
    main()
