#!/usr/bin/env python3
import argparse
import os
import sys

import mock_processing as mocks
from mock_processing.core.bitmask import BitMaskManager
from mock_processing.matching import DistributionEstimator
from mock_processing.samples import (DensitySampler, DumpConfig,
                                     RedshiftSampler, SampleManager)


parser = argparse.ArgumentParser(
    description="Apply sample selections on to obtain a mock representation "
                "of a specific photometric or spectroscopic sample.",
    add_help=False)
parser.register("action", "dump", DumpConfig)

parser.add_argument(
    "datastore", help="directory in which the data store is located")
parser.add_argument(
    "--type", default="reference", choices=SampleManager.flavours,
    help="name of the sample selection to apply (default: %(default)s)")
parser.add_argument(
    "--sample", required=True, choices=SampleManager.samples,
    help="name of the sample selection to apply")
parser.add_argument(
    "-c", "--config", required=True,
    help="parameter file in TOML format that defines data columns required "
         "for the sample selection (use --dump to obtain a default parameter "
         "file)")
parser.add_argument(
    "--area", type=float, required=True,
    help="total area in squared degrees on the sky covered by the base "
         "simulation (required by: {:})")
parser.add_argument(
    "--seed", default="sapling",
    help="string to seed the random generator (default: %(default)s, results "
         "are only reproducible for the same number of threads)")
parser.add_argument(
    "--threads", type=int, default=-1,
    help="maximum number of threads to use (default: all)")

help_group = parser.add_argument_group("help and documentation")
help_group.add_argument(
    "-h", "--help", action="help",
    help="show this help message and exit")
help_group.add_argument(
    "--dump", action="dump",
    help="dump a default configuration file for a combination of type and "
         "sample to stdout and exit (see --type and --sample for a list of "
         "valid names)")


def main():

    args = parser.parse_args()
    logger = mocks.PipeLogger(__file__, args.datastore)

    # check the configuration file
    Parser = SampleManager.get_parser(args.type, args.sample)
    config = Parser(args.config, logger)

    # apply the magnification correction to the model magnitudes
    with mocks.DataStore.open(args.datastore, False, logger=logger) as ds:
        ds.pool.max_threads = args.threads

        logger.info("apply selection funcion: {:}".format(args.sample))

        # allow the worker threads to modify the bitmask column directly
        ds.pool.allow_modify = True

        # make the output column
        BMM = BitMaskManager(args.sample)
        bitmask = ds.add_column(
            config.bitmask, dtype=BMM.dtype, overwrite=True)
        # initialize the selection bit (bit 1) to true, all subsequent
        # selections will be joined with AND
        logger.debug("initializing bit mask")
        bitmask[:] = 1

        # start with photometric selection
        try:
            selector_class = SampleManager.get_selector(args.type, args.sample)
            selector = selector_class(BMM)

            ds.pool.set_worker(selector.apply)
            # select the columns needed for the selection function
            ds.pool.add_argument_column(config.bitmask)
            for name, path in config.selection.items():
                ds.require_column(path)
                ds.pool.add_argument_column(path, keyword=name)

            # apply selection
            ds.pool.execute(seed=args.seed, prefix="photometric selection")
        except KeyError:
            pass
        except Exception as e:
            logger.handleException(e)

        # optional density sampling
        sampler_class = SampleManager.get_sampler(args.type, args.sample)
        if sampler_class is not NotImplemented:
            try:
                # surface density
                if issubclass(sampler_class, DensitySampler):
                    logger.info("estimating surface density ...")
                    sampler = sampler_class(BMM, args.area, bitmask)
                # redshift weighted density
                else:
                    logger.info("estimating redshift density ...")
                    sampler = sampler_class(
                        BMM, args.area, bitmask, ds[config.selection["redshift"]])

                ds.pool.set_worker(sampler.apply)
                # select the columns needed for the selection function
                ds.pool.add_argument_column(config.bitmask)
                # redshift weighted density requires a mock n(z) estimate
                if isinstance(sampler, RedshiftSampler):
                    ds.pool.add_argument_column(
                        config.selection["redshift"], keyword="redshift")

                # apply selection
                ds.pool.execute(seed=args.seed, prefix="density sampling")
            except KeyError:
                pass
            except Exception as e:
                logger.handleException(e)

        # add the description attribute to the output column
        bitmask.attr = {"description": BMM.description}

        # show final statistics
        N_mock = DensitySampler.count_selected(bitmask)
        density = "{:.3f} / arcminÂ²".format(N_mock / args.area / 3600.0)
        logger.info("density of selected objects: " + density)
        logger.info("computation completed for {:,d} entries".format(len(ds)))


if __name__ == "__main__":
    main()
