#!/usr/bin/env python3
import argparse
import os
import sys

import mock_processing as mocks
from mock_processing.photometry import (PhotometryParser,
                                        find_percentile_wrapped)


parser = argparse.ArgumentParser(
    description="Compute the projected effective galaxy radius from galaxy "
                "bulge (Sersic n=4) and disk (Sersic n=1) components.",
    add_help=False)
parser.register("action", "dump", PhotometryParser.get_dump())

parser.add_argument(
    "datastore", help="directory in which the data store is located")
parser.add_argument(
    "-c", "--config", required=True,
    help="parameter file in TOML format that defines the properties of the "
         "photometry realisation and the method parameters (use --dump to "
         "obtain a default parameter file)")
parser.add_argument(
    "--threads", type=int, default=-1,
    help="maximum number of threads to use (default: all)")

help_group = parser.add_argument_group("help and documentation")
help_group.add_argument(
    "-h", "--help", action="help",
    help="show this help message and exit")
help_group.add_argument(
    "--dump", nargs=0, action="dump",
    help="dump a default photometry configuratin file to stdout and exit")


def main():

    args = parser.parse_args()
    logger = mocks.PipeLogger(__file__, args.datastore)

    # check the configuration file
    config = PhotometryParser(args.config, logger)

    # apply the magnification correction to the model magnitudes
    with mocks.DataStore.open(args.datastore, False, logger=logger) as ds:
        ds.pool.max_threads = args.threads

        ds.pool.set_worker(find_percentile_wrapped)

        ds.pool.add_argument_constant(config.intrinsic["flux_frac"])

        # find disk and bulge component columns
        input_columns = (
            ("disk size", "shape/disk/size"),
            ("bulge size", "shape/bulge/size"),
            ("bulge fraction", "shape/bulge/fraction"))
        for col_desc, path in input_columns:
            ds.require_column(path, col_desc)
            ds.pool.add_argument_column(path)

        r_e_path = "shape/R_effective"
        # create the output column
        ds.add_column(
            config.intrinsic["r_effective"], dtype="f4", overwrite=True, attr={
                "description":
                "effective radius (emitting {:.1%} of the flux)".format(
                    config.intrinsic["flux_frac"])})
        # add column to call signature
        ds.pool.add_result_column(config.intrinsic["r_effective"])

        # compute and store the corrected magnitudes
        ds.pool.execute()
        logger.info("computation completed for {:,d} entries".format(len(ds)))


if __name__ == "__main__":
    main()
