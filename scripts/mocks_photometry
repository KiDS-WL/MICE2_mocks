#!/usr/bin/env python3
import argparse
import os
import sys

import mock_processing as mocks
from mock_processing.core.config import (DumpPhotometryConfig,
                                         load_photometry_config)
from mock_processing.photometry import photometry_realisation_wrapped


parser = argparse.ArgumentParser(
    description="Create a photometry realisation based on simulated apertures "
                "and magnitude limits.",
    add_help=False)
parser.register("action", "dump", DumpPhotometryConfig)

parser.add_argument(
    "datastore", help="directory in which the data store is located")

parser.add_argument(
    "--mag",
    help="sub-directory within data store which contains the input magnitudes")
parser.add_argument(
    "--real",
    help="sub-directory within data store where the photometry realisations "
         "are stored")
parser.add_argument(
    "--method", choices=("SExtractor", "GAaP"), default="SExtractor",
    help="photometry algorthim to apply (default: %(default)s)")
parser.add_argument(
    "-c", "--config", required=True,
    help="parameter file in TOML format that defines the properties of the "
         "photometry realisation and the method parameters (use --dump to "
         "obtain a default parameter file)")
parser.add_argument(
    "--no-aper", action="store_true",
    help="do not apply the aperture size depending signal-to-noise "
         "correction, running 'mocks_apertures' is no longer required")
parser.add_argument(
    "--seed", default="sapling",
    help="string to seed the random generator (default: %(default)s, results "
         "are only reproducible for the same number of threads)")
parser.add_argument(
    "--threads", type=int, default=-1,
    help="maximum number of threads to use (default: all)")

help_group = parser.add_argument_group("help and documentation")
help_group.add_argument(
    "-h", "--help", action="help",
    help="show this help message and exit")
help_group.add_argument(
    "--dump", nargs=0, action="dump",
    help="dump a default photometry configuration file to stdout and exit")


def main():

    args = parser.parse_args()
    logger = mocks.PipeLogger(__file__, args.datastore)

    # check the configuration file
    config = load_photometry_config(args.config, logger)

    # apply the magnification correction to the model magnitudes
    with mocks.DataStore.open(args.datastore, False, logger=logger) as ds:
        ds.pool.max_threads = args.threads

        # find all magnitude columns
        try:
            input_mags, _ = ds.load_photometry(args.mag)
        except KeyError as e:
            logger.handleException(e)

        # select the required magnitude columns
        available = set(input_mags.keys())
        missing = set(config.filter_names) - available
        if len(missing) > 0:
            message = "requested filters not found: {:}".format(
                ", ".join(missing))
            logger.handleException(KeyError(message))
        
        # initialize the photometry generation
        ds.pool.set_worker(photometry_realisation_wrapped)
        ds.pool.add_argument_constant(config)

        # collect the filter-specific arguments
        for key in config.filter_names:
            # 1) magnitude column
            mag_path = input_mags[key]
            ds.require_column(mag_path, "{:}-band".format(key))
            ds.pool.add_argument_column(mag_path)
            # 2) magnitude limit
            ds.pool.add_argument_constant(config.limits[key])
            # 3) S/N correction factors
            if args.no_aper:  # disable aperture correction
                ds.pool.add_argument_constant(1.0)
            else:
                snr_path = "apertures/{:}/snr_correction/{:}".format(
                    args.method, key)
                ds.require_column(
                    mag_path, "{:}-band S/N correction".format(key))
                ds.pool.add_argument_column(snr_path)

        output_columns = (  # for each filter three output columns are required
            ("{:}/{:}",
             "{:} photometry realisation (from {:}, limit: {:.2f} mag)"),
            ("{:}/{:}_err",
             "{:} photometric error (from {:}, limit: {:.2f} mag)"))
        # make the output columns for each filter
        for key in config.filter_names:
            for out_path, desc in output_columns:
                ds.add_column(
                    out_path.format(args.real, key),
                    dtype=ds[mag_path].dtype.str, overwrite=True, attr={
                        "description": desc.format(
                            args.method, mag_path, config.limits[key])})
                ds.pool.add_result_column(out_path.format(args.real, key))

        # compute and store the corrected magnitudes
        ds.pool.execute(seed=args.seed)
        logger.info("computation completed for {:,d} entries".format(len(ds)))


if __name__ == "__main__":
    main()
