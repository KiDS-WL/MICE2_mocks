#!/usr/bin/env python3
import argparse
import os
import sys
from hashlib import md5

import numpy as np

from h5table.memmap import BinaryTable
from MICE2_mocks import pipeline


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description='Create a data table with a photometery realisation based '
                    'on a table with simulated model magnitudes and '
                    'observational detection limits.')
    parser.add_argument(
        'dataset', help='memory mapped table data set with MICE2 raw data')
    parser.add_argument(
        '-c', '--chunksize', type=int, default=10000,
        help='row chunk size to process at once (default: %(default)s)')
    parser.add_argument(
        '--filters', nargs='*', required=True,
        help='list of table column names providing model magnitudes')
    parser.add_argument(
        '--limits', nargs='*', type=float, required=True,
        help='magnitude limits for each entry in --filters')
    parser.add_argument(
        '--significance', type=float, default=1.0,
        help='significance of detection against magnitude limits '
             '(default: %(default)s)')
    parser.add_argument(
        '--sn-limit', type=float, default=0.2,
        help='lower numerical limit for the signal-to-noise ratio '
             '(default: %(default)s)')
    parser.add_argument(
        '--sn-detect', type=float, default=1.0,
        help='limiting signal-to-noise ratio for object detection '
             '(default: %(default)s)')
    parser.add_argument(
        '--sn-factors', nargs='*',
        help='list of table column names of correction factors for the '
             'signal-to-noise ratio of extended sources, one '
             'for each --filter')
    parser.add_argument(
        '--seed', default='KV450',
        help='string to seed the random generator (default: %(default)s)')
    args = parser.parse_args()

    logger = pipeline.pipe_logger(__file__)

    with BinaryTable(args.dataset, mode="r+") as table:

        # check if all argument lengths match
        filters = args.filters
        if len(args.limits) != len(filters):
            message = "number of input --limits do not match --filters"
            logger.error(message)
            raise parser.error(message)
        if args.sn_factors is None:
            sn_factors = [None] * len(filters)
        else:
            sn_factors = args.sn_factors
            if len(sn_factors) != len(filters):
                message = "number of input --sn-factors do not match --filters"
                logger.error(message)
                raise parser.error(message)

        # create noise realisations
        SN_limit = args.sn_limit
        SN_detect = args.sn_detect
        non_detection_magnitude = 99.0  # inserted for non-detections
        detect_sigma_to_mag = 2.5 * np.log10(args.significance)
        # reseed the random state -> reproducible results
        hasher = md5(bytes(args.seed, "utf-8"))
        hashval = bytes(hasher.hexdigest(), "utf-8")
        np.random.seed(np.frombuffer(hashval, dtype=np.uint32))

        # compute the photometry realisation
        for mag_path, mag_lim, sn_path in zip(
                args.filters, args.limits, sn_factors):
            logger.info("processing filter '{:}'".format(mag_path))
            # find the correct magnitude path depending on whether
            # magnification was applied or not
            if mag_path.endswith("_evo"):
                obs_path = mag_path.replace("_evo", "_obs")
                err_path = mag_path.replace("_evo", "_obserr")
            else:
                if mag_path.endswith("_mag"):
                    obs_path = mag_path[:-4] + "_obs_mag"
                    err_path = mag_path[:-4] + "_obserr_mag"
                else:
                    obs_path = mag_path + "_obs"
                    err_path = mag_path + "_obserr"
            # create new output columns
            obs_mags = table.add_column(
                obs_path, dtype=table[mag_path].dtype.str, attr={
                    "description": "realisation of model magnitude"})
            obs_mags_err = table.add_column(
                err_path, dtype=table[mag_path].dtype.str, attr={
                    "description": "error of realisation of model magnitude"})

            # compute the magnitude realisation
            for start, end in table.row_iter(args.chunksize):
                if sn_path is None:
                    SN_factor = 1.0
                else:
                    SN_factor = table[sn_path][start:end]

                # compute the S/N of the model magnitudes
                model_mags = table[mag_path][start:end]
                model_SN = 10 ** (-0.4 * (
                        model_mags - mag_lim - detect_sigma_to_mag))
                model_SN *= SN_factor
                model_SN = np.maximum(model_SN, SN_limit)
                model_mags_err = 2.5 / np.log(10.0) / model_SN

                # compute the magnitde realisation and S/N
                real_mags = np.random.normal(
                    model_mags, model_mags_err, size=len(model_SN))
                real_SN = 10 ** (-0.4 * (
                        real_mags - mag_lim - detect_sigma_to_mag))
                real_SN *= SN_factor
                real_SN = np.maximum(real_SN, SN_limit)
                real_mags_err = 2.5 / np.log(10.0) / real_SN

                # set magnitudes of undetected objects and mag < 5.0 to 99.0
                not_detected = (real_SN < SN_detect) | (real_mags < 5.0)
                real_mags[not_detected] = non_detection_magnitude
                real_mags_err[not_detected] = mag_lim - detect_sigma_to_mag
                
                # write to disk
                obs_mags[start:end] = real_mags
                obs_mags_err[start:end] = real_mags_err

