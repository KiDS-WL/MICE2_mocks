#!/usr/bin/env python3
import argparse
import os
import sys
from hashlib import md5

import numpy as np
from astropy import units
from astropy.table import Column, Table

from table_tools import load_table


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description='Create a data table with a photometery realisation based '
                    'on a table with simulated model magnitudes and '
                    'observational detection limits.')

    data_group = parser.add_argument_group('data')
    data_group.add_argument(
        '-i', '--input', required=True, help='file path of input data table')
    data_group.add_argument(
        '--i-format', default='fits',
        help='astropy.table format specifier of the input table '
             '(default: %(default)s)')
    data_group.add_argument(
        '-o', '--output', required=True, help='file path of output table')
    data_group.add_argument(
        '--o-format', default='fits',
        help='astropy.table format specifier of the output table '
             '(default: %(default)s)')

    params_group = parser.add_argument_group('parameters')
    params_group.add_argument(
        '--filters', nargs='*', required=True,
        help='list of table column names providing model magnitudes')
    params_group.add_argument(
        '--limits', nargs='*', type=float, required=True,
        help='magnitude limits for each entry in --filters')
    params_group.add_argument(
        '--significance', type=float, default=1.0,
        help='significance of detection against magnitude limits '
             '(default: %(default)s)')
    params_group.add_argument(
        '--sn-limit', type=float, default=0.2,
        help='lower numerical limit for the signal-to-noise ratio '
             '(default: %(default)s)')
    params_group.add_argument(
        '--sn-detect', type=float, default=1.0,
        help='limiting signal-to-noise ratio for object detection '
             '(default: %(default)s)')
    params_group.add_argument(
        '--sn-factors', nargs='*',
        help='list of table column names of correction factors for the '
             'signal-to-noise ratio of extended sources, one '
             'for each --filter')
    params_group.add_argument(
        '--seed', default='KV450',
        help='string to seed the random generator (default: %(default)s)')

    args = parser.parse_args()

    # check if all argument lengths match
    filters = args.filters
    if len(args.limits) != len(filters):
        sys.exit("ERROR: number of input --limits do not match --filters")
    if args.sn_factors is None:
        sn_factors = [None] * len(filters)
    else:
        sn_factors = args.sn_factors
        if len(sn_factors) != len(filters):
            sys.exit(
                "ERROR: number of input --sn-factors do not match --filters")

    # load the data table and check that all required columsn exist
    columns = [f for f in filters]
    if args.sn_factors is not None:
        columns.extend(sn_factors)
    data = load_table(args.input, args.i_format, columns)
    print("use input filters: %s" % ", ".join(filters))

    # get all input magnitudes and their limits
    mag_model_data = {filt: data[filt] for filt in filters}
    mag_model_limits = {
        filt: lim for filt, lim in zip(filters, args.limits)}

    # create noise realisations
    SN_limit = args.sn_limit
    SN_detect = args.sn_detect
    non_detection_magnitude = 99.0  # inserted for non-detections
    # dictionaries that collect the magnitude realisations per filter
    mag_realisation_data = {}
    mag_realisation_error = {}
    # reseed the random state -> reproducible results
    hasher = md5(bytes(args.seed, "utf-8"))
    hashval = bytes(hasher.hexdigest(), "utf-8")
    np.random.seed(np.frombuffer(hashval, dtype=np.uint32))
    for filt, sn_key in zip(filters, sn_factors):
        if sn_key is None:
            SN_factor = 1.0
        else:
            SN_factor = data[sn_key]
        model_mags = mag_model_data[filt]
        print("processing filter '%s'" % filt)
        # compute model fluxes and the S/N
        model_flux = 10 ** (-0.4 * model_mags)
        flux_err = 10 ** (-0.4 * mag_model_limits[filt])  # universal
        model_SN = model_flux / flux_err * args.significance
        model_SN *= SN_factor  # aperture correction
        # compute the magnitde realisation and S/N
        real_flux = np.random.normal(  # approximation for Poisson error
            model_flux, flux_err, size=len(model_SN))
        real_SN = real_flux / flux_err * args.significance
        real_SN *= SN_factor  # aperture correction
        real_SN = np.maximum(real_SN, SN_limit)  # clip SN
        # compute the magnitude realisation
        real_mags = -2.5 * np.log10(real_flux)
        mags_err = 2.5 / np.log(10.0) / real_SN  # universal
        # set magnitudes of undetected objects and mag < 5.0 to 99.0
        not_detected = (real_SN < SN_detect) | (real_mags < 5.0)
        real_mags[not_detected] = non_detection_magnitude
        mags_err[not_detected] = (
            mag_model_limits[filt] - 2.5 * np.log10(args.significance))
        # collect the results
        mag_realisation_data[filt] = real_mags.astype(np.float32)
        mag_realisation_error[filt] = mags_err.astype(np.float32)

    # collect output data
    table = Table()
    for filt in filters:
        # find the correct magnitude column suffix depending on whether
        # magnification was applied or not
        if "_evo" in filt:
            key = filt.replace("_evo", "_obs")
            keyerr = filt.replace("_evo", "_obserr")
        else:
            if filt.endswith("_mag"):
                key = filt[:-4] + "_obs_mag"
                keyerr = filt[:-4] + "_obserr_mag"
            else:
                key = filt + "_obs"
                keyerr = filt + "_obserr"
        table[key] = Column(
            mag_realisation_data[filt], unit=units.mag,
            description="realisation of model magnitude")
        table[keyerr] = Column(
            mag_realisation_error[filt], unit=units.mag,
            description="error of realisation of model magnitude")

    # write to specified output path
    print("write table to: %s" % args.output)
    table.write(args.output, format=args.o_format, overwrite=True)
